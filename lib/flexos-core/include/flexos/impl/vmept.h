/* SPDX-License-Identifier: BSD-3-Clause */
/*
 * Copyright (c) 2021, Hugo Lefeuvre <hugo.lefeuvre@manchester.ac.uk>
 * 		       Stefan Teodorescu <stefanl.teodorescu@gmail.com>
 * 		       Sebastian Rauch <s.rauch94@gmail.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FLEXOS_VMEPT_H
#define FLEXOS_VMEPT_H

#include <flexos/impl/typecheck.h>
#include <flexos/impl/msgqueue.h>

#include <uk/config.h>
#include <uk/essentials.h>
#include <uk/sections.h>
#include <uk/plat/mm.h>
#include <uk/alloc.h>
#include <uk/print.h>
#include <uk/thread.h>


/* Use function pointer directly. Warning: NOT SAFE! */
#define FLEXOS_VMEPT_CALL_PROTECTION_NONE 0

/* Use IDs to identify function called via gates. */
#define FLEXOS_VMEPT_CALL_PROTECTION_ID	1

/* Use function pointers and runtime checks. TODO: implement */
#define FLEXOS_VMEPT_CALL_PROTECTION_PTR_CHECK 2

/* Must be one of the FLEXOS_VMEPT_CALL_PROTECTION_* options above. */
#define FLEXOS_VMEPT_CALL_PROTECTION FLEXOS_VMEPT_CALL_PROTECTION_ID

#if FLEXOS_VMEPT_CALL_PROTECTION == FLEXOS_VMEPT_CALL_PROTECTION_ID
/* This file is automatically generated. */
#include <flexos/impl/vmept_rpc_id.h>
#endif


/* enables/disables general debug prints */
#define FLEXOS_VMEPT_DEBUG 0

/* enables/disables printing detailed information about RPC states */
#define FLEXOS_VMEPT_DEBUG_RPC_CTRL 0

/* enables/disables printing information related to the message queues */
#define FLEXOS_VMEPT_DEBUG_MSGQUEUE 0

/* enables/disables printing information related to the RPC entries (assignment of RPC threads) */
#define FLEXOS_VMEPT_DEBUG_RPC_ENTRY 0

/* enables/disables printing information related to the control flow between threads */
#define FLEXOS_VMEPT_DEBUG_RPC_CF 0

#define FLEXOS_VMEPT_DEBUG_PRINT_ADDR 0

#if FLEXOS_VMEPT_DEBUG
	#include <stdio.h>
	#define FLEXOS_VMEPT_DEBUG_PRINT(x) uk_pr_debug x
#else
	#define FLEXOS_VMEPT_DEBUG_PRINT(x)
#endif /* FLEXOS_VMEPT_DEBUG */

#if FLEXOS_VMEPT_DEBUG_RPC_CTRL
	#define FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(x) uk_pr_debug x
#else
	#define FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(x)
#endif /* FLEXOS_VMEPT_DEBUG_RPC_CTRL */

#if FLEXOS_VMEPT_DEBUG_MSGQUEUE
	#define FLEXOS_VMEPT_DEBUG_PRINT_MSGQUEUE(x) uk_pr_debug x
#else
	#define FLEXOS_VMEPT_DEBUG_PRINT_MSGQUEUE(x)
#endif /* FLEXOS_VMEPT_DEBUG_MSGQUEUE */

#if FLEXOS_VMEPT_DEBUG_RPC_ENTRY
	#define FLEXOS_VMEPT_DEBUG_PRINT_RPC_ENTRY(x) uk_pr_debug x
#else
	#define FLEXOS_VMEPT_DEBUG_PRINT_RPC_ENTRY(x)
#endif /* FLEXOS_VMEPT_DEBUG_RPC_ENTRY */

#if FLEXOS_VMEPT_DEBUG_RPC_CF
	#define FLEXOS_VMEPT_DEBUG_PRINT_RPC_CF(x) uk_pr_debug x
#else
	#define FLEXOS_VMEPT_DEBUG_PRINT_RPC_CF(x)
#endif /* FLEXOS_VMEPT_DEBUG_RPC_CF */



#define FLEXOS_VMEPT_GATE_MICROBENCHMARK 0
#if FLEXOS_VMEPT_GATE_MICROBENCHMARK
#define FLEXOS_VEMPT_MB_CNT 4
	int flexos_vmept_mb_data[FLEXOS_VEMPT_MB_CNT];
	uint64_t flexos_vmept_mb_t0;
	uint64_t flexos_vmept_mb_t1;

	static inline __attribute__((always_inline)) void flexos_vmept_mb_store(uint8_t i, uint32_t data) {
		flexos_vmept_mb_data[i] = data;
	}

	static inline __attribute__((always_inline)) uint32_t flexos_vmept_mb_read(uint8_t i) {
		return flexos_vmept_mb_data[i];
	}

#define FLEXOS_VMEPT_MB_STORE(i, data) flexos_vmept_mb_store(i, data)
#define FLEXOS_VMEPT_MB_READ(i) flexos_vmept_mb_read(i)

#else
#define FLEXOS_VMEPT_MB_STORE(i, data)
#define FLEXOS_VMEPT_MB_READ(i)

#endif /* FLEXOS_VMEPT_GATE_MICROBENCHMARK */



/* FLEXOS_VMEPT_MAX_THREADS_SHIFT can be defined by the toolchain
 * to set the meximum number of threads available per compartment.
 * Valid options: 1...8 */
#ifndef FLEXOS_VMEPT_MAX_THREADS_SHIFT
#define FLEXOS_VMEPT_MAX_THREADS_SHIFT 8
#endif

#define FLEXOS_VMEPT_MAX_THREADS	(1 << FLEXOS_VMEPT_MAX_THREADS_SHIFT)
#define FLEXOS_VMEPT_MAX_COMPS		16

/* FELXOS_VMEPT_COMM_RESTRICT can be defined by the toolchain to
 * restrict the communication between compartmets.
 * This macro is interpreted as a 16 bi bitvector. If bit i is set
 * it means that this compartment can (directly) communicate with
 * compartment with the ID i. */
#ifndef FELXOS_VMEPT_COMM_RESTRICT
#define FELXOS_VMEPT_COMM_RESTRICT 0xFFFF
#endif

static inline int flexos_vmept_map_ctrl_chunk(uint8_t comp_id)
{
	return ((FELXOS_VMEPT_COMM_RESTRICT) >> comp_id) & 0x01;
}


/* make sure all necessary macros are defined */
#ifndef FLEXOS_VMEPT_COMP_ID 	// this compartment
#error "FLEXOS_VMEPT_COMP_ID must be defined"
#endif
#ifndef FLEXOS_VMEPT_COMP_COUNT // total number of compartments
#error "FLEXOS_VMEPT_COMP_COUNT must be defined"
#endif
#ifndef FLEXOS_VMEPT_APPCOMP 	// compartment containing the app
#error "FLEXOS_VMEPT_APPCOMP must be defined"
#endif

UK_CTASSERT(FLEXOS_VMEPT_COMP_COUNT <= FLEXOS_VMEPT_MAX_COMPS);
UK_CTASSERT(FLEXOS_VMEPT_COMP_ID >= 0);
UK_CTASSERT(FLEXOS_VMEPT_COMP_ID < FLEXOS_VMEPT_MAX_COMPS);

extern volatile uint8_t flexos_vmept_comp_id;

#if FLEXOS_VMEPT_CALL_PROTECTION == FLEXOS_VMEPT_CALL_PROTECTION_ID
	#define FLEXOS_VMEPT_READ_COMP_ID() FLEXOS_VMEPT_COMP_ID
#else
	#define FLEXOS_VMEPT_READ_COMP_ID() flexos_vmept_comp_id
#endif


struct uk_alloc;

/* Shared allocator */
extern struct uk_alloc *flexos_shared_alloc;
/* flexos_comp0_alloc is just an alias for the standard, default allocator:
 * offers memory in domain zero.
 */
#define flexos_comp0_alloc _uk_alloc_head


/* rpc states are integers and have two parts:
 * the lower 8 bits encode the state constant (see below)
 * the higher 24 bits encode a value that has a state-dependent meaning */
#define FLEXOS_VMEPT_RPC_STATE_IDLE	0
#define FLEXOS_VMEPT_RPC_STATE_CALLED	1
#define FLEXOS_VMEPT_RPC_STATE_RETURNED	2

#define FLEXOS_VMEPT_FINFO_ARGC_MASK	0x00ff
#define FLEXOS_VMEPT_FINFO_RET_MASK	0xff00

#define FLEXOS_VMEPT_BUILD_FINFO(argc, returns_val) \
((argc & FLEXOS_VMEPT_FINFO_ARGC_MASK) | ((returns_val << 8 ) & FLEXOS_VMEPT_FINFO_RET_MASK))

#define FLEXOS_VMEPT_FINFO_EXTRACT_ARGC(finfo) \
((finfo) & FLEXOS_VMEPT_FINFO_ARGC_MASK)

#define FLEXOS_VMEPT_FINFO_EXTRACT_RET(finfo) \
(((finfo) & FLEXOS_VMEPT_FINFO_RET_MASK) >> 8)

// TODO: ensure maximum size of 256 bytes
struct flexos_vmept_rpc_ctrl {
	uint64_t extended_state __attribute__ ((aligned (8)));
	uint64_t func;
	uint64_t f_info;
	uint64_t parameters[6];
	uint64_t ret;
};

#define FLEXOS_VMEPT_RPC_CTRL_SIZE 256

/* All shared memory areas below are hardcoded for now to these values. For the
 * memory sharing mechanism itself, we use our own shared memory device in QEMU
 * which receives addresses and sizes as parameters for multiple memory areas.
 *
 * TODO: These addresses and sizes should be defined by the toolchain (both
 * here and as parameters when running QEMU).
 */

/* currently it supports a maximum of 16 */
#define FLEXOS_VMEPT_RPC_PAGES_ADDR	0x800000000
#define FLEXOS_VMEPT_RPC_PAGES_SIZE	((size_t) 2 * 1024 * 1024)

#define FLEXOS_VMEPT_SHARED_HEAP_PER_COMP ((size_t) 64 * 1024 * 1024)

/* This memory area is used for the shared heap. */
#define FLEXOS_VMEPT_SHARED_MEM_ADDR	0x4000000000
#define FLEXOS_VMEPT_SHARED_MEM_SIZE	((size_t) FLEXOS_VMEPT_COMP_COUNT * FLEXOS_VMEPT_SHARED_HEAP_PER_COMP)

/* The shared_data section between all Unikraft binaries. The loader places
 * this section directly in the shared memory, so all compartments access the
 * same thing.
 */
#define FLEXOS_VMEPT_SHARED_DATA_ADDR	__SHARED_START
#define FLEXOS_VMEPT_SHARED_DATA_SIZE	((size_t) __SHARED_END - __SHARED_START)

/* the maximum number of parameters of a vmept gate
 * this is because of the calling convention
 * don't simply change this number */
#define FLEXOS_VMEPT_MAX_PARAMS	6

extern unsigned long shmem_rpc_page;

/* The shared memory layout:
 * |----------------------------------------------------|
 * | RPC message queues and init barrier (128 KB) 	|
 * |----------------------------------------------------|
 * | RPC control structures (up to 16 MB)		|
 * |----------------------------------------------------|
 */

struct flexos_vmept_msgqueue;
/* the message queues for all compartments are allocated here */
#define FLEXOS_VMEPT_MSGQUEUE_AREA_START (shmem_rpc_page)
#define FLEXOS_VMEPT_MSGQUEUE_AREA_SIZE ((FLEXOS_VMEPT_MAX_COMPS) * (sizeof(struct flexos_vmept_msgqueue)))

/* Used to ensure correct initialization order regardless of the order
 * in which compartments are started. */
struct flexos_vmept_init_barrier {
	int counters[FLEXOS_VMEPT_MAX_COMPS];
	int initialized;
};

#define FLEXOS_VMEPT_INIT_BARRIER_START ((FLEXOS_VMEPT_MSGQUEUE_AREA_START) + (FLEXOS_VMEPT_MSGQUEUE_AREA_SIZE))
#define FLEXOS_VMEPT_INIT_BARRIER_SIZE (sizeof(struct flexos_vmept_init_barrier))

#define FLEXOS_VMEPT_ROUND_UP(x, multiple) ((((x-1) / multiple) + 1) * multiple)

/* The memory area for the message queues and the init barrier are mapped into all compartments.
 * Thus we can use a simple identity mapping for this area.
 * FLEXOS_VMEPT_SHMEM_LINEAR_SIZE gives the size of this memory area. */
#define FLEXOS_VMEPT_SHMEM_LINEAR_START FLEXOS_VMEPT_MSGQUEUE_AREA_START
#define FLEXOS_VMEPT_SHMEM_LINEAR_SIZE FLEXOS_VMEPT_ROUND_UP(FLEXOS_VMEPT_MSGQUEUE_AREA_SIZE + FLEXOS_VMEPT_INIT_BARRIER_SIZE, PAGE_SIZE)

/* All RP control structures are allocated here:
 * A block contains FLEXOS_VMEPT_MAX_THREAD RPC control structures (struct flexos_vmept_rpc_ctrl).
 * A chunk contains FLEXOS_VMEPT_COMP_COUNT blocks. Chunk i is used to communicate with compartment i.
 * Block j in chunk i is used for communication between this compartment and compartment i
 * for call chains originating from compartment j (the corresponding normal thread is in compartment j). */
#define FLEXOS_VMEPT_RPC_CTRL_BLOCK_SIZE (FLEXOS_VMEPT_MAX_THREADS) * (FLEXOS_VMEPT_RPC_CTRL_SIZE)
#define FLEXOS_VMEPT_RPC_CTRL_CHUNK_SIZE (FLEXOS_VMEPT_COMP_COUNT) * (FLEXOS_VMEPT_RPC_CTRL_BLOCK_SIZE)
#define FLEXOS_VMEPT_RPC_CTRL_AREA_START FLEXOS_VMEPT_ROUND_UP((FLEXOS_VMEPT_INIT_BARRIER_START) + (FLEXOS_VMEPT_INIT_BARRIER_SIZE), PAGE_SIZE)
#define FLEXOS_VMEPT_RPC_CTRL_AREA_SIZE ((FLEXOS_VMEPT_MAX_COMPS) * (FLEXOS_VMEPT_RPC_CTRL_CHUNKS_SIZE))

/* Compute the index of the RPC control chunk used for communication between compartments
 * comp_id_a and comp_id_b. This is used to set up the memory mapping for pairwise sharing
 * of the RPC control chunks. */
unsigned int flexos_vmept_rpc_ctrl_chunk_index(uint8_t comp_id_a, uint8_t comp_id_b);

static inline __attribute__((always_inline)) int flexos_vmept_rpc_index(uint8_t comp_id, uint8_t tid)
{
	return (comp_id << (FLEXOS_VMEPT_MAX_THREADS_SHIFT)) | tid;
}

static inline __attribute__((always_inline)) int flexos_vmept_rpc_msg(int rpc_index, uint8_t key_from)
{
	return rpc_index | (key_from << (4 + (FLEXOS_VMEPT_MAX_THREADS_SHIFT)));
}

static inline __attribute__((always_inline)) int flexos_vmept_extract_rpc_index(int rpc_msg)
{
	return rpc_msg & (0x0FFF >> (8 - (FLEXOS_VMEPT_MAX_THREADS_SHIFT)));
}

static inline __attribute__((always_inline)) uint8_t flexos_vmept_extract_other_comp(int rpc_msg)
{
	return rpc_msg >> (4 + (FLEXOS_VMEPT_MAX_THREADS_SHIFT));
}

static inline __attribute__((always_inline)) volatile struct flexos_vmept_rpc_ctrl* flexos_vmept_get_rpc_ctrl(int rpc_index, uint8_t comp_to)
{
	return (volatile struct flexos_vmept_rpc_ctrl*) (FLEXOS_VMEPT_RPC_CTRL_AREA_START +
		comp_to * FLEXOS_VMEPT_RPC_CTRL_CHUNK_SIZE + rpc_index * FLEXOS_VMEPT_RPC_CTRL_SIZE);
}

static inline __attribute__((always_inline)) volatile struct flexos_vmept_msgqueue* flexos_vmept_get_own_msgqueue()
{
	return (volatile struct flexos_vmept_msgqueue*) ((FLEXOS_VMEPT_MSGQUEUE_AREA_START)
		+ FLEXOS_VMEPT_READ_COMP_ID() * sizeof(struct flexos_vmept_msgqueue));
}

static inline __attribute__((always_inline)) volatile struct flexos_vmept_msgqueue* flexos_vmept_get_msgqueue(uint8_t comp_id)
{
	return (volatile struct flexos_vmept_msgqueue*) ((FLEXOS_VMEPT_MSGQUEUE_AREA_START)
		+ comp_id * sizeof(struct flexos_vmept_msgqueue));
}

struct uk_thread;
/* determines how many idle RPC threads exist concurrently */
#ifndef FLEXOS_VMEPT_MAX_IDLE_THREADS
#define FLEXOS_VMEPT_MAX_IDLE_THREADS 256
#endif

/* stack size for RPC threads  */
#define FLEXOS_VMEPT_RPC_STACK_SIZE 64 * 1024
#define FLEXOS_VMEPT_RPC_INIT_THREAD_POOL_SIZE 1

struct flexos_vmept_rpc_entry {
	struct uk_thread *thread;
	int recursion;
};

struct flexos_vmept_rpc_thread_mgr {
	struct uk_thread *idle_threads[FLEXOS_VMEPT_MAX_IDLE_THREADS];
	int thread_cnt;
	int idle_cnt;
	struct uk_thread *rpc_server_thread;
	struct flexos_vmept_rpc_entry active_entries[FLEXOS_VMEPT_COMP_COUNT * FLEXOS_VMEPT_MAX_THREADS];
};

/* Initialize the compartments in ascending order of compartment ID
 * (regardles of the order they are started in).  */
void flexos_vmept_init();

/* Add new idle rpc thread. */
int flexos_vmept_add_idle_rpc_thread(struct flexos_vmept_rpc_thread_mgr *thread_mgr);

/* main loop of the RPC server */
void *flexos_vmept_rpc_server_loop(void *arg __unused);

void *flexos_vmept_rpc_thread_func(void *arg);

static inline __attribute__((always_inline)) void flexos_vmept_init_rpc_ctrl(volatile struct flexos_vmept_rpc_ctrl *ctrl)
{
	/* key_from and _key_to are set to 0 */
	ctrl->extended_state = FLEXOS_VMEPT_RPC_STATE_IDLE;
}

static inline __attribute__((always_inline)) int flexos_vmept_extract_state(uint64_t extended_state)
{
	return (int) extended_state;
}

static inline __attribute__((always_inline)) uint8_t flexos_vmept_extract_key_from(uint64_t extended_state)
{
	return (uint8_t) ((extended_state >> 32) & 0xff);
}

static inline __attribute__((always_inline)) uint8_t flexos_vmept_extract_key_to(uint64_t extended_state)
{
	return (uint8_t) ((extended_state >> 40) & 0xff);
}

/* to facilitate debugging */
static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_extended_state(
	volatile struct flexos_vmept_rpc_ctrl *ctrl, int state, uint8_t key_from, uint8_t key_to)
{
	uint64_t ext_state = (((uint64_t) key_from) << 32) | (((uint64_t) key_to) << 40) | state;
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting extended_state to %016lx.\n", ctrl, flexos_vmept_comp_id, ext_state));
	ctrl->extended_state = ext_state;
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_func(
	volatile struct flexos_vmept_rpc_ctrl *ctrl, uint64_t func, uint8_t argc, uint8_t returns_val)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting func to %lu and f_info to %016lx.\n", ctrl, flexos_vmept_comp_id,
		func, FLEXOS_VMEPT_BUILD_FINFO(argc, returns_val)));
	ctrl->func = func;
	ctrl->f_info = FLEXOS_VMEPT_BUILD_FINFO(argc, returns_val);
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_ret(
	volatile struct flexos_vmept_rpc_ctrl *ctrl, uint64_t ret)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting ret to %016lx.\n", ctrl, flexos_vmept_comp_id, ret));
	ctrl->ret = ret;
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_args1(
	volatile struct flexos_vmept_rpc_ctrl *ctrl, uint64_t arg1)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting %d args (%016lx).\n",
		ctrl, flexos_vmept_comp_id, 1, arg1));
	ctrl->parameters[0] = arg1;
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_args2(
	volatile struct flexos_vmept_rpc_ctrl *ctrl, uint64_t arg1, uint64_t arg2)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting %d args (%016lx, %016lx).\n",
		ctrl, flexos_vmept_comp_id, 2, arg1, arg2));
	ctrl->parameters[0] = arg1;
	ctrl->parameters[1] = arg2;
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_args3(
	volatile struct flexos_vmept_rpc_ctrl *ctrl,
	uint64_t arg1, uint64_t arg2, uint64_t arg3)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting %d args (%016lx, %016lx, %016lx).\n",
		ctrl, flexos_vmept_comp_id, 3, arg1, arg2, arg3));
	ctrl->parameters[0] = arg1;
	ctrl->parameters[1] = arg2;
	ctrl->parameters[2] = arg3;
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_args4(
	volatile struct flexos_vmept_rpc_ctrl *ctrl,
	uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting %d args (%016lx, %016lx, %016lx, %016lx).\n",
		ctrl, flexos_vmept_comp_id, 4, arg1, arg2, arg3, arg4));
	ctrl->parameters[0] = arg1;
	ctrl->parameters[1] = arg2;
	ctrl->parameters[2] = arg3;
	ctrl->parameters[3] = arg4;
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_args5(
	volatile struct flexos_vmept_rpc_ctrl *ctrl,
	uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting %d args (%016lx, %016lx, %016lx, %016lx, %016lx).\n",
		ctrl, flexos_vmept_comp_id, 5, arg1, arg2, arg3, arg4, arg5));
	ctrl->parameters[0] = arg1;
	ctrl->parameters[1] = arg2;
	ctrl->parameters[2] = arg3;
	ctrl->parameters[3] = arg4;
	ctrl->parameters[4] = arg5;
}

static inline __attribute__((always_inline)) void flexos_vmept_ctrl_set_args6(
	volatile struct flexos_vmept_rpc_ctrl *ctrl,
	uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6)
{
	FLEXOS_VMEPT_DEBUG_PRINT_RPC_CTRL(("(ctrl %p) comp %d setting %d args (%04lx, %04lx, %04lx, %04lx, %04lx, %04lx).\n",
		ctrl, flexos_vmept_comp_id, 6, arg1, arg2, arg3, arg4, arg5, arg6));
	ctrl->parameters[0] = arg1;
	ctrl->parameters[1] = arg2;
	ctrl->parameters[2] = arg3;
	ctrl->parameters[3] = arg4;
	ctrl->parameters[4] = arg5;
	ctrl->parameters[5] = arg6;
}

#define FLEXOS_VMEPT_VOID 0
#define FLEXOS_VMEPT_NONVOID 1

uint64_t flexos_vmept_execute_rpc(volatile struct flexos_vmept_rpc_ctrl *ctrl,
	struct uk_thread *current_thread, uint8_t key_from, uint8_t key_to, int rpc_index);

#define flexos_vmept_gate0(key_from, key_to, func)								\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl); 											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 0, FLEXOS_VMEPT_VOID);					\
	flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);			\
} while (0)

#define flexos_vmept_gate0_r(key_from, key_to, retval, func)							\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 0, FLEXOS_VMEPT_NONVOID);					\
	(retval) = flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);		\
} while (0)

#define flexos_vmept_gate1(key_from, key_to, func, arg1)							\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args1(_gate_ctrl, (uint64_t) arg1);						\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 1, FLEXOS_VMEPT_VOID);					\
	flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);			\
} while (0)

#define flexos_vmept_gate1_r(key_from, key_to, retval, func, arg1)						\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args1(_gate_ctrl, (uint64_t) arg1);						\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 1, FLEXOS_VMEPT_NONVOID);					\
	(retval) = flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);		\
} while (0)

#define flexos_vmept_gate2(key_from, key_to, func, arg1, arg2)							\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args2(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2);				\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 2, FLEXOS_VMEPT_VOID);					\
	flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);			\
} while (0)

#define flexos_vmept_gate2_r(key_from, key_to, retval, func, arg1, arg2)					\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args2(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2);				\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 2, FLEXOS_VMEPT_NONVOID);					\
	(retval) = flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);		\
} while (0)

#define flexos_vmept_gate3(key_from, key_to, func, arg1, arg2, arg3)						\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args3(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3);										\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 3, FLEXOS_VMEPT_VOID);					\
	flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);			\
} while (0)

#define flexos_vmept_gate3_r(key_from, key_to, retval, func, arg1, arg2, arg3)					\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args3(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3);										\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 3, FLEXOS_VMEPT_NONVOID);					\
	(retval) = flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);		\
} while (0)

#define flexos_vmept_gate4(key_from, key_to, func, arg1, arg2, arg3, arg4)					\
do {														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args4(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3, (uint64_t) arg4);								\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 4, FLEXOS_VMEPT_VOID);					\
	flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);			\
} while (0)

#define flexos_vmept_gate4_r(key_from, key_to, retval, func, arg1, arg2, arg3, arg4)				\
do {														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args4(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3, (uint64_t) arg4);								\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 4, FLEXOS_VMEPT_NONVOID);					\
	(retval) = flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);		\
} while (0)

#define flexos_vmept_gate5(key_from, key_to, func, arg1, arg2, arg3, arg4, arg5)				\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args5(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3, (uint64_t) arg4, (uint64_t) arg5);						\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 5, FLEXOS_VMEPT_VOID);					\
	flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);			\
} while (0)

#define flexos_vmept_gate5_r(key_from, key_to, retval, func, arg1, arg2, arg3, arg4, arg5)			\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args5(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3, (uint64_t) arg4, (uint64_t) arg5);						\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 5, FLEXOS_VMEPT_NONVOID);					\
	(retval) = flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);		\
} while (0)

#define flexos_vmept_gate6(key_from, key_to, func, arg1, arg2, arg3, arg4, arg5, arg6)				\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args6(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3, (uint64_t) arg4, (uint64_t) arg5, (uint64_t) arg6);				\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 6, FLEXOS_VMEPT_VOID);					\
	flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);			\
} while (0)

#define flexos_vmept_gate6_r(key_from, key_to, retval, func, arg1, arg2, arg3, arg4, arg5, arg6)		\
do {														\
	UK_ASSERT(key_from == flexos_vmept_comp_id);														\
	struct uk_thread *_gate_thread = uk_thread_current();							\
	int rpc_index = _gate_thread->rpc_index;								\
	volatile struct flexos_vmept_rpc_ctrl *_gate_ctrl = flexos_vmept_get_rpc_ctrl(rpc_index, key_to);	\
	UK_ASSERT(_gate_ctrl);											\
	flexos_vmept_ctrl_set_extended_state(_gate_ctrl, FLEXOS_VMEPT_RPC_STATE_IDLE, 0, 0);			\
	flexos_vmept_ctrl_set_args6(_gate_ctrl, (uint64_t) arg1, (uint64_t) arg2,				\
		(uint64_t) arg3, (uint64_t) arg4, (uint64_t) arg5, (uint64_t) arg6);				\
	flexos_vmept_ctrl_set_func(_gate_ctrl, func, 6, FLEXOS_VMEPT_NONVOID);					\
	(retval) = flexos_vmept_execute_rpc(_gate_ctrl, _gate_thread, key_from, key_to, rpc_index);		\
} while (0)

/* A variation of the argument counting trick to choose the right gate based on the
 * number of arguments given. Don't use more than 6 arguments!  */
#define CHOOSE_GATE(dummy, g6, g5, g4, g3, g2, g1, g0, ...) g0

/* flexos_vmept_gate(1, 0, printf, "hello\n")
 * -> execute printf("hello\n") is protection domain (VM) 0 */
#define flexos_vmept_gate(key_from, key_to, fname, ...)					\
CHOOSE_GATE(dummy, ## __VA_ARGS__,							\
	flexos_vmept_gate6(key_from, key_to, (fname), __VA_ARGS__),			\
	flexos_vmept_gate5(key_from, key_to, (fname), __VA_ARGS__), 			\
	flexos_vmept_gate4(key_from, key_to, (fname), __VA_ARGS__), 			\
	flexos_vmept_gate3(key_from, key_to, (fname), __VA_ARGS__), 			\
	flexos_vmept_gate2(key_from, key_to, (fname), __VA_ARGS__), 			\
	flexos_vmept_gate1(key_from, key_to, (fname), __VA_ARGS__), 			\
	flexos_vmept_gate0(key_from, key_to, (fname)) 					\
)

#define flexos_vmept_gate_r(key_from, key_to, retval, fname, ...)			\
CHOOSE_GATE(dummy, ## __VA_ARGS__,							\
	flexos_vmept_gate6_r(key_from, key_to, retval, (fname), __VA_ARGS__),		\
	flexos_vmept_gate5_r(key_from, key_to, retval, (fname), __VA_ARGS__), 		\
	flexos_vmept_gate4_r(key_from, key_to, retval, (fname), __VA_ARGS__), 		\
	flexos_vmept_gate3_r(key_from, key_to, retval, (fname), __VA_ARGS__), 		\
	flexos_vmept_gate2_r(key_from, key_to, retval, (fname), __VA_ARGS__), 		\
	flexos_vmept_gate1_r(key_from, key_to, retval, (fname), __VA_ARGS__), 		\
	flexos_vmept_gate0_r(key_from, key_to, retval, (fname)) 			\
)

#endif /* FLEXOS_VMEPT_H */
